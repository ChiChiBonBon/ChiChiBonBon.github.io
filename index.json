[{"categories":["技術札記"],"contents":"HTTP協議 規定資料傳輸格式，以便前後端可溝通 區分Request和Response兩種 HTTP Request Http Method URL Request Head Request Body HTTP Response Http Status Code Response Head Response Body URL格式 http//localhost:8080/test 協議(http//) 域名(localhost) 埠號(:8080) 路徑(/test) @RequestMapping 用法:加上class或方法上，括號中填寫域名 用途:控制器導路徑，執行對應的方法 要點:使用時一定要加@RestController或@Controller，括號中不包含域名 @RestController @RequestMapping(\u0026#34;/detail\u0026#34;) public class MyController{ @RequestMapping(\u0026#34;/test\u0026#34;) public String test(){ System.out.println(\u0026#34;test\u0026#34;); return \u0026#34;Sucess\u0026#34;; } } Controller/RestController 用法:加在class上 用途:生成控制器，可視為@Component的加強版 @RestController public class MyController{ //...do something } JSON JSON是一種輕量級資料交換格式 用途:結構化呈現數據 Value值的類型:1. 整數 2. 浮點數 3. 字串 4.布林值 { \u0026#34;Integer\u0026#34;:10, \u0026#34;Float\u0026#34;:99.9, \u0026#34;String\u0026#34;:\u0026#34;Hello\u0026#34;, \u0026#34;Boolean\u0026#34;:true } Controller和RestController的差別 @Controller public class MyController{ @ResponseBody @RequestMapping(\u0026#34;/test\u0026#34;) public Ojbect test(){ Object obj = new object; return obj; } } @RestController public class MyController{ @RequestMapping(\u0026#34;/test\u0026#34;) public Object test(){ Object obj = new object; return obj; } } HTTP Method GET:類似明信片，傳遞的參數會被看見 POST:類似信封，傳遞的參數不會被看見 @RequestParam 用法:只能加在參數上 用途:從URL中抓取值 參數設定:name、Required、defaultValue http://localhost:8080/test?sn=6688\n@RestController public class MyController{ @RequestMapping(\u0026#34;/test\u0026#34;) public Integer test(@RequestParam(name=\u0026#34;sn\u0026#34;,defaultValue=\u0026#34;0\u0026#34;,Required=\u0026#34;true\u0026#34;) Intgeer id){ return id; } } @RequestBody 用法:只能加在參數上 用途:POST方法中抓取ReuestBody中的JSON, 並轉成Java Object 要點:ReuestBody中多帶值，Spring Boot會忽略，RequestBody少帶值，值會是Null POST Method:http://localhost:8080/test RequestBody: { \u0026#34;id\u0026#34;:123, \u0026#34;name\u0026#34;:\u0026#34;Jason\u0026#34; } @RestController public class MyController{ @RequestMapping(\u0026#34;/test\u0026#34;) public Student test(@RequestBody Studnet student){ return student; } } public class student{ private Integer id; private String name; //...getter and setter } @RequestHeader 用法:只能加在參數上 用途:取得RequestHeader的參數 參數設定:name、defaultValue、Required public class MyController{ @RequestMapping(\u0026#34;/test\u0026#34;) public String test(@RequestHeader(name = \u0026#34;Content-Type\u0026#34;,defaultValue = \u0026#34;application/json\u0026#34;,Required = \u0026#34;true\u0026#34;) String contentType){ System.out.println(\u0026#34;Content-Type:\u0026#34; + contentType); return contentType; } } @PathVariable 用法:只能加在方法參數上 用途:取得URL路徑中的值 @RestController public class MyController{ @ReqeustMapping(\u0026#34;/post/{id}\u0026#34;) public String post(@PathVariable Integer id){ System.out.println(\u0026#34;PathVarialbe:\u0026#34; + id); return id; } } @PathVariable 與 @RequestParam的差別 特性 @PathVariable @RequestParam 传参方式 URL 路径中的参数 URL 查询参数 (Query Parameter) 常见请求方法 主要用于 GET，也可用于 POST, PUT, DELETE 主要用于 GET，也可用于 POST RESTful 风格 ✅ 非常适合 RESTful API（资源路径标识） ❌ 一般用于过滤、排序、分页等非资源标识 参数是否可选 通常是必须的（因为是路径的一部分） 支持可选参数和默认值 请求示例 /user/123 /user?id=123\u0026amp;sort=asc 使用场景 资源标识，例如获取/修改特定 ID 的对象 过滤、分页、搜索、排序等查询参数 Restful API 特點:Get、Delete沒有RequestBody，而Post、Put有RequestBody Spring Boot參數驗證 Valid和Validated的使用差別 @Valid 适用于 @RequestBody @Valid 是 Java Bean Validation（JSR-303/JSR-380 规范）的一部分，通常用于 对象 的验证，适用于 @RequestBody 解析的 JSON 或 XML。 为什么 @Valid 适用于 @RequestBody？ @RequestBody 用于接收 JSON 或 XML 并转换成 Java 对象。 @Valid 会在 对象绑定到 Java Bean 之后 进行验证。 适用于 DTO（Data Transfer Object），即请求体是 Java 对象。\n@RestController @RequestMapping(\u0026#34;/users\u0026#34;) public class UserController { @PostMapping(\u0026#34;/create\u0026#34;) public ResponseEntity\u0026lt;String\u0026gt; createUser(@Valid @RequestBody UserDTO userDTO) { return ResponseEntity.ok(\u0026#34;User created successfully!\u0026#34;); } } DTO 类\npublic class UserDTO { @NotNull(message = \u0026#34;Username cannot be null\u0026#34;) @Size(min = 3, message = \u0026#34;Username must be at least 3 characters long\u0026#34;) private String username; @Email(message = \u0026#34;Invalid email format\u0026#34;) private String email; // Getters and Setters } 🔹 这里 @Valid 会确保 UserDTO 中的字段符合约束条件，否则 Spring 会返回 400 Bad Request。\n@Validated 适用于 @RequestParam、@PathVariable、@RequestHeader @Validated 是 Spring 提供的增强版校验注解，支持 单个参数 及 分组校验。 为什么 @Validated 适用于 @RequestParam、@PathVariable、@RequestHeader？ 这些参数通常是 基本数据类型（如 String、Integer） 或 单个值，而不是 Java Bean。 @Valid 只能用在 Java Bean，不能用于 基本数据类型。 @Validated 适用于 方法参数级别，包括基本数据类型的校验。\n@RestController @RequestMapping(\u0026#34;/users\u0026#34;) @Validated // 需要加在类上，或者方法参数前 public class UserController { @GetMapping(\u0026#34;/{id}\u0026#34;) public ResponseEntity\u0026lt;String\u0026gt; getUser( @PathVariable @Min(value = 1, message = \u0026#34;ID must be greater than 0\u0026#34;) Long id) { return ResponseEntity.ok(\u0026#34;User ID: \u0026#34; + id); } @GetMapping(\u0026#34;/search\u0026#34;) public ResponseEntity\u0026lt;String\u0026gt; searchUser( @RequestParam @NotBlank(message = \u0026#34;Query cannot be blank\u0026#34;) String query) { return ResponseEntity.ok(\u0026#34;Search query: \u0026#34; + query); } @GetMapping(\u0026#34;/header\u0026#34;) public ResponseEntity\u0026lt;String\u0026gt; checkHeader( @RequestHeader(\u0026#34;X-Request-ID\u0026#34;) @NotBlank(message = \u0026#34;Request ID is required\u0026#34;) String requestId) { return ResponseEntity.ok(\u0026#34;Request ID: \u0026#34; + requestId); } } 🔹 这里 @Validated 允许对 路径参数、查询参数、请求头参数 进行校验。\n@Validated 还能支持分组校验 如果需要 根据不同情况 进行不同的校验，@Validated 提供了 分组校验，这是 @Valid 没有的功能。 public class UserDTO { public interface Create {} public interface Update {} @NotNull(groups = Update.class, message = \u0026#34;ID is required for update\u0026#34;) private Long id; @NotNull(groups = Create.class, message = \u0026#34;Username cannot be null\u0026#34;) @Size(min = 3, message = \u0026#34;Username must be at least 3 characters long\u0026#34;) private String username; } @PostMapping(\u0026#34;/create\u0026#34;) public ResponseEntity\u0026lt;String\u0026gt; createUser(@Validated(UserDTO.Create.class) @RequestBody UserDTO userDTO) { return ResponseEntity.ok(\u0026#34;User created!\u0026#34;); } @PutMapping(\u0026#34;/update\u0026#34;) public ResponseEntity\u0026lt;String\u0026gt; updateUser(@Validated(UserDTO.Update.class) @RequestBody UserDTO userDTO) { return ResponseEntity.ok(\u0026#34;User updated!\u0026#34;); } 🔹 这里 @Validated 允许指定 不同的校验规则组，这样 createUser 和 updateUser 可以使用不同的规则。\n总结 适用范围\t注解\t适用情况\t作用 @RequestBody\t@Valid\t用于 DTO（对象）\t触发 Bean Validation @RequestParam、@PathVariable、@RequestHeader\t@Validated\t用于基本数据类型和单个参数\t触发参数级别验证 @RequestBody（支持分组）\t@Validated\tDTO（对象）\t额外支持分组校验 💡 简单来说：\n@Valid 用于 @RequestBody 解析的 Java Bean 对象。 @Validated 用于 @RequestParam、@PathVariable、@RequestHeader 这些 单个值 或 基本类型。 @Validated 还能支持分组校验，@Valid 不能。 这样就能清楚地知道 @Valid 和 @Validated 的使用区别了！😊\nHTTP狀態碼 用來表示請求回應後的電文狀態為何 可以根據首字的號碼區隔五大類 1xx狀態碼 資訊類 2xx狀態碼 成功類 200 OK 請求成功 201 Created 請求成功且已建立資源，通常用在POST的Response 202 Accepted 請求已經接受，尚未處理完 3xx狀態碼 重新導向類 301 Moved Permanently 網址永久性搬家，Response Header中的location要放新的url 302 found 網址暫時性搬家，Response Header中的location要放新的url 4xx狀態碼 前端錯誤類 400 Bad Request 前端請求錯誤，如:前後端參數不一致、請求的格式有誤 401 Unauthorized 沒有通過身份驗證 403 Forbidden 請求沒後端拒絕 404 Not Found 網頁不存在，可能資源移走或URL的路徑錯誤 5xx狀態碼 後端錯誤類 500 Internal Server Error 後端執行程式發生錯誤，可能有bug 503 Service Unavailable 由於臨時維護或流量太大，後端無法處理請求 504 Gateway Timeout 請求超時 ResponseEntity 用法:作為方法的返回類型 用途:自定義Response回傳的細節 要點:Spring Boot預設報錯是500，預設成功是200 @RestController Public class MyController{ @ReqeustMapping(\u0026#34;/test\u0026#34;) public ResponseEntity\u0026lt;String\u0026gt; test(){ return ResponseEntity.status(HttpStatus.ACCEPTED) .body(\u0026#34;Accepted 202\u0026#34;); } ControllerAdvice 用法:只能加在class上 用途:將這個class生成bean，並在內部使用@ExceptionHandler ExceptionHandler 用法:只能加在方法上 用途:catch方法所報錯的Exception @RestController public class MyController{ @RequestMapping(\u0026#34;/test\u0026#34;) public ResponseEntity\u0026lt;String\u0026gt; test(){ throw new RuntimeException(\u0026#34;RuntimeException\u0026#34;); } } @ControllerAdvice public class MyExceptionHandler{ @ExceptionHandler(RuntimeException.class) public ResponseEntity\u0026lt;String\u0026gt; test(RuntimeException exception){ return ResponseEntity.status(HttpStatus.SERVICE_UAVALIABLE) .body(\u0026#34;Exception:\u0026#34; + exception.getMessage();); } } Interceptor 用法:實作HandleInterceptor 用途:處理送到controller之前的請求，如:身份驗證、日誌記錄 @Component public class MyInterceptor implements HandlerInterceptor{ @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\u0026#34;處理身份驗證\u0026#34;); response.setStatus(401); return false; } } @Configuration public class MyConfig implements WebMvcConfigurer { @Autowired private MyInterceptor myInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(myInterceptor).addPathPatterns(\u0026#34;/**\u0026#34;); } } ","permalink":"https://chichibonbon.github.io/blog/spring-mvc/","tags":["Java"],"title":"Spring MVC常用的Annotation"},{"categories":["技術札記"],"contents":"Spring AOP @Aspect 用法:需與Bean一起使用，帶有@Component的class 用途:切面導向設計，共同邏輯程式碼重用，宣告某class是切面\n@Aspect @Component public class MyAspect{ //to something } Before 用法:加在@Aspect的class之方法上 用途:在方法執行前，處理共用邏輯\n@Aspect @Component public class MyAspect{ @Before(\u0026#34;excution(* com.example.demo.HpPrinter.*(..))\u0026#34;) public void before(){ System.out.println(\u0026#34;Before\u0026#34;); } } After 用法:加在@Aspect的class之方法上 用途:在方法執行後，處理共用邏輯\n@Aspect @Component public class MyAspect{ @after(\u0026#34;excution(* com.example.demo.HpPrinter.*(..))\u0026#34;) public void after(){ System.out.println(\u0026#34;After\u0026#34;); } } Around 用法:加在@Aspect的class之法上 用途:在方法執行前、後，處理共用邏輯\npublic class MyAspect{ @Around(\u0026#34;execution(* com.example.demo.HpPrinter.*(..))\u0026#34;) public Object around(ProceedingJoinPoint pjp) throws Throwable{ Date start = new Date(); System.out.println(\u0026#34;I\u0026#39;m before\u0026#34;); Object obj = pjp.proceed(); Date end = new Date(); System.out.println(\u0026#34;I\u0026#39;m after\u0026#34;); long time = end.getTime() - start.getTime(); System.out.println(\u0026#34;時間差:\u0026#34; + time + \u0026#34;ms\u0026#34;); return obj; } } 重點整理 Spring AOP的應用 權限控管:Spring Security 統一例外處理:@ControllerAdvice Log日誌記錄 ","permalink":"https://chichibonbon.github.io/blog/spring-aop/","tags":["Java"],"title":"Spring AOP概念"},{"categories":["技術札記"],"contents":"Spring IoC注入與Bean概念 IoC 概念 將Object的控制權交給外部Spring容器管理 Bean 被Spring容器創建的object，叫做bean Spring中的物件名稱為Bean名字class nanme的第一字母轉小寫 @Component 用法:只能加在class上 用途:將該class變成由Spring容器所管理的object @Componet public class Poodle implements dog { @Override public void bark(String message){ System.out.println(message); } } @Autowired 用法:加在實體變數中 用途:IoC機制會把物件自動丟入實體變數中，實際就是自動做了new一個物件 @Component public class master{ @Autowired private Dog poodle; public void play(){ poodle.bark(\u0026#34;I\u0026#39;m happy.\u0026#34;); } } @Qualifier 用法:通常加在實體變數上，會跟@Autowired一起用 用途:指定要戴入的bean的名字 public class master{ @Autowired @Qualifier(\u0026#34;hachi\u0026#34;) private Dog poodle; public void perform(){ poodle.bark(\u0026#34;I\u0026#39;m hurry.\u0026#34;); } } DI依賴注入 將Object注入到另一個Object 某物件依賴於另一個物件 public interface Biological{ survive(); } @Component public class Fish implements Biological{ public void suvive(){ System.out.println(\u0026#34;I\u0026#39;m alive.\u0026#34;); } } @Component public class Cat{ private Fish fish; public void catch(Fish fish){ fish.survive(); } } @Configuration 用法:寫在class上面 用途:用來設定Spring容器的config @Configuration public class MyConfiguration{ //do something } @Bean 用法:寫在帶有@Configuration的class之方法上 用途:用來設定Spring容器需要的Bean物件 @Configuration public class MyConfiguration{ @Bean(\u0026#34;connectSetUp\u0026#34;) public Connection conn(){ return new Connection(); } } @PostConstruct 用法:寫在帶有@Component的Class中或是Bean的方法上面 用途:設定Bean中的實體變數的初始值 要點1:1.方法要是public 2.方法的回傳要是void 3.方法名沒有硬性規定 4.方法沒有傳參 要點2:擇一使用afterProperitiesSet或@PostConstruct @Component public class MyBean{ private int initValue; @PostConstruct public void setUp{ initValue = 5; } public int caculate(){ initValue--; System.out.println(\u0026#34;當前值:\u0026#34; + initValue); return initValue; } } afterProperitiesSet 用法:實作InitializingBean的方法afterProperitiesSet 用途:初始化Bean中的實體變數 要點:擇一使用afterProperitiesSet或@PostConstruct @Component public class MyBean implements InitializingBean{ private int initiValue; @Override public void afterProperitiesSet throws Exception(){ initiValue = 5; System.out.println(\u0026#34;當前值:\u0026#34; + initValue); } public int caculate(){ initValue--; System.out.println(\u0026#34;當前值:\u0026#34; + initValue); return initValue; } } @RestController 用法:加在Class上面 用途:作為控制器來轉送後端路由 @RequestMapping 用法:加在方法上面 用途:作為控制器中的各個不同路徑 @RestController public class MyController{ @RequestMapping(\u0026#34;/test\u0026#34;) public String test(){ System.out.println(\u0026#34;Hello World!!\u0026#34;); } } Bean的生命週期 Bean創建生成 \u0026ndash;\u0026gt; Bean初始化 \u0026ndash;\u0026gt; Bean依賴注入(DI) Bean創建時，若有其他依賴注入的Bean沒有建立、初始化，會優先回去處理生成Bean(創建+初始化) 若Spring Boot有任一Bean建立失敗，會使程式報錯 不要寫出循環依賴的程式: A依賴B,B依賴A Spring Boot設定檔 用法:使用properties語法(key=value) 用途:設定Spring Boot的設定檔 application.properties dbConnection=127.0.0.1:1733 dbUser.name=Jason dbUser.password=P@ssW0rd @value 用法:加在Bean中的變數或加在有@Configuration的class中之變數 用途:讀取Spring Boot的設定檔 要點:1.格式:${key} 2.設定檔中的值要與Java變數型態一致 3.可設定預設值:${key:default} @Configuration public class MyConfiguration{ @Value(${dbConnection}) private String dbConnection; @Bean(\u0026#34;conn\u0026#34;) public Connection conn(){ return new Connection } } @Component public class MyBean{ @Value(${dbUser.name:root}) private String name; } properties語法 V.S yml語法 properties語法 gender=male my.name=Jason my.phone=0912345678 # This is comment yml語法 gender=male my: name: Jason phone: 0912345678 # This is comment ","permalink":"https://chichibonbon.github.io/blog/spring-ioc/","tags":["Java"],"title":"Spring IoC常用的Annotation"},{"categories":["學習技巧"],"contents":"Markdown用法 文字使用: 普通文字 直接打\n一級標題 二級標題 三級標題 四級標題 五級標題 六級標題 我是邦尼，我喜歡兔子\n紐西蘭大白兔 澳洲大黑兔 道奇兔 2. 北道海雪兔 紅色 *藍色 白色 *黑色 public static void manin(String){ System.out.println\nGoogle My github\nMy github\n我是一隻邦尼 Hello World\npublic static void main(String args[]){ System.out.print(\u0026#34;Hello World\u0026#34;); } Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 Owl bet you\u0026#39;ll lose this staring contest 🦉 pic.twitter.com/eJh4f2zncC\n\u0026mdash; San Diego Zoo Wildlife Alliance (@sandiegozoo) October 26, 2021 View this post on Instagram ","permalink":"https://chichibonbon.github.io/blog/markdownintro/","tags":["Markdown"],"title":"邦尼的第一篇文章上線啦~Markdown用法"},{"categories":["技術札記"],"contents":"如何使用Docker Docker的安裝 查看當前Linux版本 cat /etc/os-release 清除CLI的畫面 clear 更新系統套件索引並安裝必要的依賴項 sudo apt update sudo apt install apt-transport-https ca-certificates curl gnupg 添加Docker的官方GPG密鑰 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker.gpg 將Docker的官方存儲庫添加到系統 echo \u0026#34;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu noble stable\u0026#34; | sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null 更新套件索引並安裝Docker sudo apt update sudo apt install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin 驗證Docker是否安裝成功 sudo systemctl is-active docker 查看當前docker版本 sudo docker --version 啟動特定的服務 sudo service docker start 查看本地docker images sudo docker images 抓取docker image 名叫hello-world sudo docker pull hello-world 再次查看本地docker images sudo docker images 啟動dokcer image 名叫hello-world sudo docker run hello-world 關掉docker engine sudo service docker stop 允許非root用戶運行Docker命令 sudo usermod -aG docker ${USER} ","permalink":"https://chichibonbon.github.io/blog/docker-start/","tags":["Docker"],"title":"docker學習記"}]