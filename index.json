[{"categories":["技術札記"],"contents":"HTTP協議 規定資料傳輸格式，以便前後端可溝通 區分Request和Response兩種 HTTP Request Http Method URL Request Head Request Body HTTP Response Http Status Code Response Head Response Body URL格式 http//localhost:8080/test 協議(http//) 域名(localhost) 埠號(:8080) 路徑(/test) @RequestMapping 用法:加上class或方法上，括號中填寫域名 用途:控制器導路徑，執行對應的方法 要點:使用時一定要加@RestController或@Controller，括號中不包含域名 @RestController @RequestMapping(\u0026#34;/detail\u0026#34;) public class MyController{ @RequestMapping(\u0026#34;/test\u0026#34;) public String test(){ System.out.println(\u0026#34;test\u0026#34;); return \u0026#34;Sucess\u0026#34;; } } Controller/RestController 用法:加在class上 用途:生成控制器，可視為@Component的加強版 @RestController public class MyController{ //...do something } JSON JSON是一種輕量級資料交換格式 用途:結構化呈現數據 Value值的類型:1. 整數 2. 浮點數 3. 字串 4.布林值 { \u0026#34;Integer\u0026#34;:10, \u0026#34;Float\u0026#34;:99.9, \u0026#34;String\u0026#34;:\u0026#34;Hello\u0026#34;, \u0026#34;Boolean\u0026#34;:true } Controller和RestController的差別 @Controller public class MyController{ @ResponseBody @RequestMapping(\u0026#34;/test\u0026#34;) public Ojbect test(){ Object obj = new object; return obj; } } @RestController public class MyController{ @RequestMapping(\u0026#34;/test\u0026#34;) public Object test(){ Object obj = new object; return obj; } } HTTP Method GET:類似明信片，傳遞的參數會被看見 POST:類似信封，傳遞的參數不會被看見 @RequestParam 用法:只能加在參數上 用途:從URL中抓取值 參數設定:name、Required、defaultValue http://localhost:8080/test?sn=6688\n@RestController public class MyController{ @RequestMapping(\u0026#34;/test\u0026#34;) public Integer test(@RequestParam(name=\u0026#34;sn\u0026#34;,defaultValue=\u0026#34;0\u0026#34;,Required=\u0026#34;true\u0026#34;) Intgeer id){ return id; } } @RequestBody 用法:只能加在參數上 用途:POST方法中抓取ReuestBody中的JSON, 並轉成Java Object 要點:ReuestBody中多帶值，Spring Boot會忽略，RequestBody少帶值，值會是Null POST Method:http://localhost:8080/test RequestBody: { \u0026#34;id\u0026#34;:123, \u0026#34;name\u0026#34;:\u0026#34;Jason\u0026#34; } @RestController public class MyController{ @RequestMapping(\u0026#34;/test\u0026#34;) public Student test(@RequestBody Studnet student){ return student; } } public class student{ private Integer id; private String name; //...getter and setter } @RequestHeader 用法:只能加在參數上 用途:取得RequestHeader的參數 參數設定:name、defaultValue、Required public class MyController{ @RequestMapping(\u0026#34;/test\u0026#34;) public String test(@RequestHeader(name = \u0026#34;Content-Type\u0026#34;,defaultValue = \u0026#34;application/json\u0026#34;,Required = \u0026#34;true\u0026#34;) String contentType){ System.out.println(\u0026#34;Content-Type:\u0026#34; + contentType); return contentType; } } @PathVariable 用法:只能加在方法參數上 用途:取得URL路徑中的值 @RestController public class MyController{ @ReqeustMapping(\u0026#34;/post/{id}\u0026#34;) public String post(@PathVariable Integer id){ System.out.println(\u0026#34;PathVarialbe:\u0026#34; + id); return id; } } @PathVariable 與 @RequestParam的差別 特性 @PathVariable @RequestParam 传参方式 URL 路径中的参数 URL 查询参数 (Query Parameter) 常见请求方法 主要用于 GET，也可用于 POST, PUT, DELETE 主要用于 GET，也可用于 POST RESTful 风格 ✅ 非常适合 RESTful API（资源路径标识） ❌ 一般用于过滤、排序、分页等非资源标识 参数是否可选 通常是必须的（因为是路径的一部分） 支持可选参数和默认值 请求示例 /user/123 /user?id=123\u0026amp;sort=asc 使用场景 资源标识，例如获取/修改特定 ID 的对象 过滤、分页、搜索、排序等查询参数 Restful API ","permalink":"https://chichibonbon.github.io/blog/spring-mvc/","tags":["Java"],"title":"Spring MVC常用的Annotation"},{"categories":["技術札記"],"contents":"Spring AOP @Aspect 用法:需與Bean一起使用，帶有@Component的class 用途:切面導向設計，共同邏輯程式碼重用，宣告某class是切面\n@Aspect @Component public class MyAspect{ //to something } Before 用法:加在@Aspect的class之方法上 用途:在方法執行前，處理共用邏輯\n@Aspect @Component public class MyAspect{ @Before(\u0026#34;excution(* com.example.demo.HpPrinter.*(..))\u0026#34;) public void before(){ System.out.println(\u0026#34;Before\u0026#34;); } } After 用法:加在@Aspect的class之方法上 用途:在方法執行後，處理共用邏輯\n@Aspect @Component public class MyAspect{ @after(\u0026#34;excution(* com.example.demo.HpPrinter.*(..))\u0026#34;) public void after(){ System.out.println(\u0026#34;After\u0026#34;); } } Around 用法:加在@Aspect的class之法上 用途:在方法執行前、後，處理共用邏輯\npublic class MyAspect{ @Around(\u0026#34;execution(* com.example.demo.HpPrinter.*(..))\u0026#34;) public Object around(ProceedingJoinPoint pjp) throws Throwable{ Date start = new Date(); System.out.println(\u0026#34;I\u0026#39;m before\u0026#34;); Object obj = pjp.proceed(); Date end = new Date(); System.out.println(\u0026#34;I\u0026#39;m after\u0026#34;); long time = end.getTime() - start.getTime(); System.out.println(\u0026#34;時間差:\u0026#34; + time + \u0026#34;ms\u0026#34;); return obj; } } 重點整理 Spring AOP的應用 權限控管:Spring Security 統一例外處理:@ControllerAdvice Log日誌記錄 ","permalink":"https://chichibonbon.github.io/blog/spring-aop/","tags":["Java"],"title":"Spring AOP概念"},{"categories":["技術札記"],"contents":"Spring IoC注入與Bean概念 IoC 概念 將Object的控制權交給外部Spring容器管理 Bean 被Spring容器創建的object，叫做bean Spring中的物件名稱為Bean名字class nanme的第一字母轉小寫 @Component 用法:只能加在class上 用途:將該class變成由Spring容器所管理的object @Componet public class Poodle implements dog { @Override public void bark(String message){ System.out.println(message); } } @Autowired 用法:加在實體變數中 用途:IoC機制會把物件自動丟入實體變數中，實際就是自動做了new一個物件 @Component public class master{ @Autowired private Dog poodle; public void play(){ poodle.bark(\u0026#34;I\u0026#39;m happy.\u0026#34;); } } @Qualifier 用法:通常加在實體變數上，會跟@Autowired一起用 用途:指定要戴入的bean的名字 public class master{ @Autowired @Qualifier(\u0026#34;hachi\u0026#34;) private Dog poodle; public void perform(){ poodle.bark(\u0026#34;I\u0026#39;m hurry.\u0026#34;); } } DI依賴注入 將Object注入到另一個Object 某物件依賴於另一個物件 public interface Biological{ survive(); } @Component public class Fish implements Biological{ public void suvive(){ System.out.println(\u0026#34;I\u0026#39;m alive.\u0026#34;); } } @Component public class Cat{ private Fish fish; public void catch(Fish fish){ fish.survive(); } } @Configuration 用法:寫在class上面 用途:用來設定Spring容器的config @Configuration public class MyConfiguration{ //do something } @Bean 用法:寫在帶有@Configuration的class之方法上 用途:用來設定Spring容器需要的Bean物件 @Configuration public class MyConfiguration{ @Bean(\u0026#34;connectSetUp\u0026#34;) public Connection conn(){ return new Connection(); } } @PostConstruct 用法:寫在帶有@Component的Class中或是Bean的方法上面 用途:設定Bean中的實體變數的初始值 要點1:1.方法要是public 2.方法的回傳要是void 3.方法名沒有硬性規定 4.方法沒有傳參 要點2:擇一使用afterProperitiesSet或@PostConstruct @Component public class MyBean{ private int initValue; @PostConstruct public void setUp{ initValue = 5; } public int caculate(){ initValue--; System.out.println(\u0026#34;當前值:\u0026#34; + initValue); return initValue; } } afterProperitiesSet 用法:實作InitializingBean的方法afterProperitiesSet 用途:初始化Bean中的實體變數 要點:擇一使用afterProperitiesSet或@PostConstruct @Component public class MyBean implements InitializingBean{ private int initiValue; @Override public void afterProperitiesSet throws Exception(){ initiValue = 5; System.out.println(\u0026#34;當前值:\u0026#34; + initValue); } public int caculate(){ initValue--; System.out.println(\u0026#34;當前值:\u0026#34; + initValue); return initValue; } } @RestController 用法:加在Class上面 用途:作為控制器來轉送後端路由 @RequestMapping 用法:加在方法上面 用途:作為控制器中的各個不同路徑 @RestController public class MyController{ @RequestMapping(\u0026#34;/test\u0026#34;) public String test(){ System.out.println(\u0026#34;Hello World!!\u0026#34;); } } Bean的生命週期 Bean創建生成 \u0026ndash;\u0026gt; Bean初始化 \u0026ndash;\u0026gt; Bean依賴注入(DI) Bean創建時，若有其他依賴注入的Bean沒有建立、初始化，會優先回去處理生成Bean(創建+初始化) 若Spring Boot有任一Bean建立失敗，會使程式報錯 不要寫出循環依賴的程式: A依賴B,B依賴A Spring Boot設定檔 用法:使用properties語法(key=value) 用途:設定Spring Boot的設定檔 application.properties dbConnection=127.0.0.1:1733 dbUser.name=Jason dbUser.password=P@ssW0rd @value 用法:加在Bean中的變數或加在有@Configuration的class中之變數 用途:讀取Spring Boot的設定檔 要點:1.格式:${key} 2.設定檔中的值要與Java變數型態一致 3.可設定預設值:${key:default} @Configuration public class MyConfiguration{ @Value(${dbConnection}) private String dbConnection; @Bean(\u0026#34;conn\u0026#34;) public Connection conn(){ return new Connection } } @Component public class MyBean{ @Value(${dbUser.name:root}) private String name; } properties語法 V.S yml語法 properties語法 gender=male my.name=Jason my.phone=0912345678 # This is comment yml語法 gender=male my: name: Jason phone: 0912345678 # This is comment ","permalink":"https://chichibonbon.github.io/blog/spring-ioc/","tags":["Java"],"title":"Spring IoC常用的Annotation"},{"categories":["學習技巧"],"contents":"Markdown用法 文字使用: 普通文字 直接打\n一級標題 二級標題 三級標題 四級標題 五級標題 六級標題 我是邦尼，我喜歡兔子\n紐西蘭大白兔 澳洲大黑兔 道奇兔 2. 北道海雪兔 紅色 *藍色 白色 *黑色 public static void manin(String){ System.out.println\nGoogle My github\nMy github\n我是一隻邦尼 Hello World\npublic static void main(String args[]){ System.out.print(\u0026#34;Hello World\u0026#34;); } Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 Owl bet you\u0026#39;ll lose this staring contest 🦉 pic.twitter.com/eJh4f2zncC\n\u0026mdash; San Diego Zoo Wildlife Alliance (@sandiegozoo) October 26, 2021 View this post on Instagram ","permalink":"https://chichibonbon.github.io/blog/markdownintro/","tags":["Markdown"],"title":"邦尼的第一篇文章上線啦~Markdown用法"},{"categories":["技術札記"],"contents":"如何使用Docker Docker的安裝 查看當前Linux版本 cat /etc/os-release 清除CLI的畫面 clear 更新系統套件索引並安裝必要的依賴項 sudo apt update sudo apt install apt-transport-https ca-certificates curl gnupg 添加Docker的官方GPG密鑰 curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker.gpg 將Docker的官方存儲庫添加到系統 echo \u0026#34;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu noble stable\u0026#34; | sudo tee /etc/apt/sources.list.d/docker.list \u0026gt; /dev/null 更新套件索引並安裝Docker sudo apt update sudo apt install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin 驗證Docker是否安裝成功 sudo systemctl is-active docker 查看當前docker版本 sudo docker --version 啟動特定的服務 sudo service docker start 查看本地docker images sudo docker images 抓取docker image 名叫hello-world sudo docker pull hello-world 再次查看本地docker images sudo docker images 啟動dokcer image 名叫hello-world sudo docker run hello-world 關掉docker engine sudo service docker stop 允許非root用戶運行Docker命令 sudo usermod -aG docker ${USER} ","permalink":"https://chichibonbon.github.io/blog/docker-start/","tags":["Docker"],"title":"docker學習記"}]